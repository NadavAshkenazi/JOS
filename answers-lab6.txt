=== Q How did you structure your transmit implementation?
===  In particular, what do you do if the transmit ring is full?

in output function we wait to receive an ipc req, then we spin on sys_transmit until it succeeds (with sys_yield in between loops).
sys_transmit will fail as long as the ring is full, therefor we will try again.

=== Q How did you structure your receive implementation? In particular, what do you do if 
===  In particular, what do you do if the receive queue is empty and a user environment 
=== requests the next incoming packet?

in input function we wait to we spin on sys_receive until it succeeds (with sys_yield in between loops).
sys_receive will fail as long as the ring is full, therefor we will try again.

=== Q What does the web page served by JOS's web server say?
This file came from JOS.
Cheesy web page!

=== Q How long approximately did it take you to do this lab?
7 sessions (half days)

====================================================================
=== Challenges:

=== Challenge: EEPROM

we questioned the EEPROM for the MAC address by writing and reading words to the EEPROM Read Register.
we also implemented a SYSCALL that uses this functionality to read the MAC address so we'll be able to rewrite the hard coded MAC in lwip code.


=== Challenge: ZERO COPY

we used page mapping and unmapping to send over packets, therefore we did not copy and data.

in input we allocate a page with a certain VA. then we sys_transmit it which inturn converts this VA into a pageInfo.
sys_transmit calls e1000_transmit which inserts the page PA into the ring.
when this PA is reieved in e1000_receive in is converted back to a pageInfo and the mapped to a new VA in sys_receive and return to the recipient.
thus, by "ping-pingoing" this PA between sender and recipient, we avoided copying data.


=== Challenge: CHAT SERVER

we used echo server infrastructure as skelaton code and modified it to be able to connect between several users on demand.
we used on main server env and several client-listener envs that comunicate through IPC and handle in-server comunication.
each listener listens over a user socket to its input, then sends an IPC message to the main server which in turn sends a msg packet over each of the other user sockets.
we also implemented syncing barriers via syscalls to syncronize between server and listner stages.

we also handled buffer overflows by killing the server and the participants when one occurs.
this is done via a "monitored envs" mechnism which consists of:
 * monitoredFork() - forks and adds env to monitored envs list
 * monitored env SYSCALLS - allows questioning and killing the list of monitored envs.

testing the server is done through:

1. make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-chatsrv
2. write num of participants (between 2 and 9)
3. open as much terminals as you requested and make nc-7 (from lab dir)
4. for each terminal, provide username
5. start chating
6. to exit, simply send a ##_EXIT_## msg from any user or ctrl-C from any user.


